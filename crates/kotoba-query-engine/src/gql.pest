// GQL Grammar for Pest Parser
// ISO GQL (ISO/IEC 9075-16:2023) subset

// Main rules
query = { SOI ~ (match_clause | where_clause | return_clause)* ~ EOI }
statement = { SOI ~ (create_statement | drop_statement | insert_statement) ~ EOI }

// Keywords
MATCH = { "MATCH" }
OPTIONAL = { "OPTIONAL" }
WHERE = { "WHERE" }
RETURN = { "RETURN" }
DISTINCT = { "DISTINCT" }
AS = { "AS" }
CREATE = { "CREATE" }
DROP = { "DROP" }
INSERT = { "INSERT" }
GRAPH = { "GRAPH" }
VERTEX = { "VERTEX" }
EDGE = { "EDGE" }
IF = { "IF" }
NOT = { "NOT" }
EXISTS = { "EXISTS" }

// MATCH clause
match_clause = { MATCH ~ (OPTIONAL)? ~ graph_pattern }

// Graph pattern
graph_pattern = { path_pattern ~ ("," ~ path_pattern)* }

// Path pattern
path_pattern = { (variable ~ "=")? ~ path_element }

// Path element
path_element = { vertex_pattern ~ (edge_pattern ~ vertex_pattern)* }

// Vertex pattern
vertex_pattern = { "(" ~ (variable)? ~ (label)* ~ (properties)? ~ ")" }

// Edge pattern
edge_pattern = { left_arrow | right_arrow | undirected }

// Edge directions
left_arrow = { "<-" ~ (variable)? ~ (label)* ~ (properties)? ~ "-" }
right_arrow = { "-" ~ (variable)? ~ (label)* ~ (properties)? ~ ">" }
undirected = { "-" ~ (variable)? ~ (label)* ~ (properties)? ~ "-" }

// Labels
label = { ":" ~ identifier }

// Properties
properties = { "{" ~ property ~ ("," ~ property)* ~ "}" }
property = { string ~ ":" ~ expression }

// Variable
variable = { identifier }

// WHERE clause
where_clause = { WHERE ~ boolean_expression }

// Boolean expressions
boolean_expression = { comparison_expression | exists_expression | logical_expression }
comparison_expression = { expression ~ comparison_operator ~ expression }
exists_expression = { EXISTS ~ "(" ~ graph_pattern ~ ")" }
logical_expression = { boolean_expression ~ logical_operator ~ boolean_expression }

// Comparison operators
comparison_operator = { "=" | "!=" | "<" | "<=" | ">" | ">=" | "=~" }

// Logical operators
logical_operator = { "AND" | "OR" }

// RETURN clause
return_clause = { RETURN ~ (DISTINCT)? ~ return_item ~ ("," ~ return_item)* }

// Return item
return_item = { expression ~ (AS ~ identifier)? }

// Expressions
expression = { value_expression | function_call | property_access }

// Value expressions
value_expression = { literal | variable | "(" ~ expression ~ ")" }

// Literals
literal = { string | number | boolean | NULL }

// Function calls
function_call = { identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

// Property access
property_access = { expression ~ "." ~ identifier }

// Basic tokens
identifier = { (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
string = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" | "'" ~ (!"'" ~ ANY)* ~ "'" }
number = { ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean = { "TRUE" | "FALSE" }
NULL = { "NULL" }

// Statements
create_statement = { CREATE ~ (create_graph | create_vertex | create_edge) }
drop_statement = { DROP ~ (drop_graph) }
insert_statement = { INSERT ~ insert_clause }

create_graph = { GRAPH ~ (IF ~ NOT ~ EXISTS)? ~ identifier }
drop_graph = { GRAPH ~ (IF ~ EXISTS)? ~ identifier }
create_vertex = { VERTEX ~ vertex_pattern }
create_edge = { EDGE ~ edge_pattern }

insert_clause = { vertex_insert ~ ("," ~ edge_insert)* }
vertex_insert = { "(" ~ (variable)? ~ (label)* ~ (properties)? ~ ")" }
edge_insert = { "(" ~ variable ~ ")" ~ edge_pattern ~ "(" ~ variable ~ ")" }

// Whitespace and comments
WHITESPACE = { (" " | "\t" | "\r" | "\n")+ }
COMMENT = { ("#" | "//") ~ (!"\n" ~ ANY)* ~ "\n" }

// Skip whitespace and comments
skip = { WHITESPACE | COMMENT }
