// GQL Grammar for Pest Parser
// ISO GQL (ISO/IEC 9075-16:2023) subset

// Main rules
query = { (match_clause | where_clause | return_clause)* }
statement = { (create_statement | delete_statement | insert_statement) }

// Keywords
MATCH = { "MATCH" }
OPTIONAL = { "OPTIONAL" }
WHERE = { "WHERE" }
RETURN = { "RETURN" }
DISTINCT = { "DISTINCT" }
AS = { "AS" }
CREATE = { "CREATE" }
DELETE = { "DELETE" }
INSERT = { "INSERT" }
GRAPH = { "GRAPH" }
VERTEX = { "VERTEX" }
EDGE = { "EDGE" }
IF = { "IF" }
NOT = { "NOT" }
EXISTS = { "EXISTS" }

// MATCH clause
match_clause = { MATCH ~ (OPTIONAL)? ~ graph_pattern }

// Graph pattern
graph_pattern = { path_pattern ~ ("," ~ path_pattern)* }

// Path pattern
path_pattern = { (variable ~ "=")? ~ path_element }

// Path element
path_element = { vertex_pattern ~ (edge_pattern ~ vertex_pattern)* }

// Vertex pattern
vertex_pattern = { "(" ~ (variable)? ~ (label)* ~ (properties)? ~ ")" }

// Edge pattern
edge_pattern = { left_arrow | right_arrow | undirected }

// Edge directions
left_arrow = { "<-" ~ (variable)? ~ (label)* ~ (properties)? ~ "-" }
right_arrow = { "-" ~ (variable)? ~ (label)* ~ (properties)? ~ ">" }
undirected = { "-" ~ (variable)? ~ (label)* ~ (properties)? ~ "-" }

// Labels
label = { ":" ~ identifier }

// Properties
properties = { "{" ~ property ~ ("," ~ property)* ~ "}" }
property = { string ~ ":" ~ expression }

// Variable
variable = { identifier }

// WHERE clause
where_clause = { WHERE ~ boolean_expression }

// Boolean expressions (using precedence climbing)
boolean_expression = { or_expression }
or_expression = { and_expression ~ ("OR" ~ and_expression)* }
and_expression = { not_expression ~ ("AND" ~ not_expression)* }
not_expression = { ("NOT")? ~ comparison_expression }
comparison_expression = { primary_expression ~ comparison_operator ~ primary_expression }
primary_expression = { literal | variable | "(" ~ boolean_expression ~ ")" | exists_expression | function_call }

// Comparison operators
comparison_operator = { "=" | "!=" | "<" | "<=" | ">" | ">=" | "=~" }

// Exists expression
exists_expression = { EXISTS ~ "(" ~ graph_pattern ~ ")" }

// RETURN clause
return_clause = { RETURN ~ (DISTINCT)? ~ return_item ~ ("," ~ return_item)* }

// Return item
return_item = { expression ~ (AS ~ identifier)? }

// Expressions (using precedence climbing)
expression = { additive_expression }
additive_expression = { multiplicative_expression ~ (("+" | "-") ~ multiplicative_expression)* }
multiplicative_expression = { unary_expression ~ (("*" | "/") ~ unary_expression)* }
unary_expression = { ("-" | "+")? ~ primary_expression }


// Literals
literal = { string | number | boolean | NULL }

// Function calls
function_call = { identifier ~ "(" ~ (expression ~ ("," ~ expression)*)? ~ ")" }

// Property access
property_access = { variable ~ ("." ~ identifier)+ }

// Basic tokens
identifier = { (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
string = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" | "'" ~ (!"'" ~ ANY)* ~ "'" }
number = { ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)? }
boolean = { "TRUE" | "FALSE" }
NULL = { "NULL" }

// Statements
create_statement = { CREATE ~ (create_graph | create_vertex | create_edge) }
delete_statement = { DELETE ~ (delete_graph) }
insert_statement = { INSERT ~ insert_clause }

create_graph = { GRAPH ~ (IF ~ NOT ~ EXISTS)? ~ identifier }
delete_graph = { GRAPH ~ (IF ~ EXISTS)? ~ identifier }
create_vertex = { VERTEX ~ vertex_pattern }
create_edge = { EDGE ~ edge_pattern }

insert_clause = { vertex_insert ~ ("," ~ edge_insert)* }
vertex_insert = { "(" ~ (variable)? ~ (label)* ~ (properties)? ~ ")" }
edge_insert = { "(" ~ variable ~ ")" ~ edge_pattern ~ "(" ~ variable ~ ")" }

// Whitespace and comments
WHITESPACE = { (" " | "\t" | "\r" | "\n")+ }
COMMENT = { ("#" | "//") ~ (!"\n" ~ ANY)* ~ "\n" }

// Skip whitespace and comments
skip = { WHITESPACE | COMMENT }
