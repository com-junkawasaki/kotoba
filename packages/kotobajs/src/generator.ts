// MERKLE: b2c9e8f1 (Code generator logic)
import fs from 'fs/promises';
import path from 'path';

// MERKLE: 3f0a1b2c (JSON Schema to KotobaSchema converter)

// A simple converter to map JSON Schema types to our `k` validator calls.
function jsonSchemaToKotobaSchema(property: any): string {
  switch (property.type) {
    case 'string': {
      let chain = 'k.string()';
      if (property.minLength !== undefined) {
        chain += `.min(${property.minLength})`;
      }
      if (property.format === 'email') {
        chain += `.email()`;
      }
      if (property.format === 'uuid') {
        // Assuming a uuid() check exists or will be added
        // chain += `.uuid()`;
      }
      if (property.format === 'date-time') {
        // Assuming a datetime() check exists or will be added
        // chain += `.datetime()`;
      }
      return chain;
    }
    case 'integer':
    case 'number': {
      let chain = 'k.number()';
      if (property.type === 'integer') {
        chain += `.int()`;
      }
      if (property.minimum !== undefined) {
        chain += `.min(${property.minimum})`;
      }
      return chain;
    }
    default:
      return 'k.any()'; // Fallback for unsupported types
  }
}

async function generateValidationSchema(schema: any, outputPath: string): Promise<void> {
  const modelName = schema.title;
  if (!modelName) {
    throw new Error('Schema must have a title');
  }

  const properties = Object.entries(schema.properties)
    .map(([key, value]) => {
      const isOptional = !schema.required?.includes(key);
      const validator = jsonSchemaToKotobaSchema(value);
      // MERKLE: ${modelName}.${key}
      return `  // ${schema.properties[key].description || ''}\n  ${key}: ${validator}${isOptional ? '.optional()' : ''},`;
    })
    .join('\n');

  const content = `// This file is auto-generated by @kotoba/kotobajs-cli. Do not edit directly.
// MERKLE: ${modelName}Schema

import { k, infer } from '../../validation/schema';

export const ${modelName}Schema = k.object({
${properties}
});

export type ${modelName} = infer<typeof ${modelName}Schema>;
`;

  const filePath = path.join(outputPath, 'schemas', `${modelName.toLowerCase()}.ts`);
  await fs.writeFile(filePath, content);
  console.log(`   ✓ Created validation schema: ${filePath}`);
}

async function generateModelClass(schema: any, outputPath: string): Promise<void> {
  const modelName = schema.title;
  const schemaName = `${modelName}Schema`;
  const schemaFileName = modelName.toLowerCase();

  const content = `// This file is auto-generated by @kotoba/kotobajs-cli. Do not edit directly.
// MERKLE: ${modelName}Model

import { Vertex } from '../../model/vertex';
import { ${schemaName} } from '../schemas/${schemaFileName}';

// Represents a '${modelName}' vertex in the graph.
export class ${modelName} extends Vertex<typeof ${schemaName}> {
  public static readonly schema = ${schemaName};

  // You can add custom methods to this class in a separate, non-generated file.
}
`;

  const filePath = path.join(outputPath, 'models', `${modelName.toLowerCase()}.ts`);
  await fs.writeFile(filePath, content);
  console.log(`   ✓ Created model class: ${filePath}`);
}

async function generateEdgeModelClass(schema: any, outputPath: string): Promise<void> {
  const modelName = schema.title;
  const schemaName = `${modelName}Schema`;
  const schemaFileName = modelName.toLowerCase();
  const sourceModel = schema['kotoba:source'];
  const destinationModel = schema['kotoba:destination'];

  const content = `// This file is auto-generated by @kotoba/kotobajs-cli. Do not edit directly.
// MERKLE: ${modelName}EdgeModel

import { Edge } from '../../model/edge';
import { ${schemaName} } from '../schemas/${schemaFileName}';
import { ${sourceModel} } from './${sourceModel.toLowerCase()}';
import { ${destinationModel} } from './${destinationModel.toLowerCase()}';

// Represents a '${modelName}' edge in the graph.
export class ${modelName} extends Edge<typeof ${schemaName}, ${sourceModel}, ${destinationModel}> {
  public static readonly schema = ${schemaName};
}
`;
  const filePath = path.join(outputPath, 'models', `${modelName.toLowerCase()}.ts`);
  await fs.writeFile(filePath, content);
  console.log(`   ✓ Created edge model class: ${filePath}`);
}


export interface GenerateOptions {
  schemaPath: string;
  outputPath: string;
}

export async function generate(options: GenerateOptions): Promise<void> {
  const { schemaPath, outputPath } = options;
  console.log(`Reading schemas from: ${path.resolve(schemaPath)}`);

  // 1. Ensure output directories exist
  await fs.mkdir(path.join(outputPath, 'schemas'), { recursive: true });
  await fs.mkdir(path.join(outputPath, 'models'), { recursive: true });
  await fs.mkdir(path.join(outputPath, 'types'), { recursive: true });


  // 2. Read schema directory
  const schemaFiles = await fs.readdir(schemaPath);

  for (const file of schemaFiles) {
    if (file.endsWith('.schema.json')) {
      console.log(` - Processing ${file}...`);
      const schemaContent = await fs.readFile(path.join(schemaPath, file), 'utf-8');
      const schema = JSON.parse(schemaContent);
      
      await generateValidationSchema(schema, outputPath);
      
      if (schema['kotoba:type'] === 'edge') {
        await generateEdgeModelClass(schema, outputPath);
      } else {
        await generateModelClass(schema, outputPath);
      }
    }
  }
}
