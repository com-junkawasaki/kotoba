//! WebAssembly Transpiler for Kotoba UI-IR
//!
//! Converts UI-IR graphs to Rust code that can be compiled to WebAssembly
//! for client-side execution in browsers.

use crate::{Error, Result};
use kotoba_types::{Node, UiNodeType, UiProperties};
use std::collections::HashMap;

/// WebAssembly Transpiler
pub struct WasmTranspiler {
    next_id: u32,
}

impl WasmTranspiler {
    pub fn new() -> Self {
        WasmTranspiler { next_id: 0 }
    }

    /// Transpile UI-IR to Rust code for WebAssembly
    pub fn transpile_to_rust(&mut self, ui_nodes: &[Node], root_node_id: &str) -> Result<String> {
        let mut output = String::new();

        // Generate WASM runtime imports and setup
        output.push_str(&self.generate_preamble());

        // Generate component definitions
        let mut components = Vec::new();
        let mut states = Vec::new();

        for node in ui_nodes {
            match self.get_ui_node_type(node)? {
                UiNodeType::View => {
                    // Views are the root containers
                    components.push(self.generate_view_component(node)?);
                }
                UiNodeType::Component => {
                    // UI components (buttons, inputs, etc.)
                    components.push(self.generate_ui_component(node)?);
                }
                UiNodeType::State => {
                    // State management
                    states.push(self.generate_state(node)?);
                }
                _ => {
                    // Other node types are handled differently or ignored for WASM
                }
            }
        }

        // Generate main application
        output.push_str(&self.generate_main_app(root_node_id, &components, &states));

        // Generate WASM runtime functions
        output.push_str(&self.generate_runtime_functions());

        Ok(output)
    }

    fn generate_preamble(&self) -> String {
        r#"// Generated by Kotoba WASM Transpiler
// This code is compiled to WebAssembly and runs in the browser

use wasm_bindgen::prelude::*;
use web_sys::{window, document, Element, HtmlElement, Node as DomNode};
use js_sys::{Object, Reflect};
use serde::{Deserialize, Serialize};

// WASM runtime imports
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &str, b: &str);
}

// Macro for console.log
macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

// DOM manipulation utilities
#[derive(Clone)]
pub struct ElementRef {
    element: Element,
}

impl ElementRef {
    pub fn new(tag: &str) -> Result<Self> {
        let window = web_sys::window().ok_or("No window")?;
        let document = window.document().ok_or("No document")?;
        let element = document.create_element(tag)
            .map_err(|_| "Failed to create element")?;

        Ok(ElementRef { element })
    }

    pub fn set_attribute(&self, name: &str, value: &str) -> Result<()> {
        self.element.set_attribute(name, value)
            .map_err(|_| "Failed to set attribute")?;
        Ok(())
    }

    pub fn set_text_content(&self, text: &str) {
        self.element.set_text_content(Some(text));
    }

    pub fn append_child(&self, parent: &ElementRef) -> Result<()> {
        parent.element.append_child(&self.element)
            .map_err(|_| "Failed to append child")?;
        Ok(())
    }

    pub fn add_event_listener<F>(&self, event: &str, callback: F) -> Result<()>
    where
        F: FnMut(web_sys::Event) + 'static,
    {
        let closure = Closure::wrap(Box::new(callback) as Box<dyn FnMut(_)>);
        self.element.add_event_listener_with_callback(event, closure.as_ref().unchecked_ref())
            .map_err(|_| "Failed to add event listener")?;
        closure.forget(); // Leak the closure to keep it alive
        Ok(())
    }

    pub fn get_element(&self) -> &Element {
        &self.element
    }
}

"#.to_string()
    }

    fn generate_view_component(&mut self, node: &Node) -> Result<String> {
        let component_name = format!("View{}", self.next_id);
        self.next_id += 1;

        let ui_props = self.parse_ui_properties(node)?;

        let mut code = format!(r#"
// View Component: {}
#[derive(Clone)]
pub struct {} {{
    root: ElementRef,
    children: Vec<Box<dyn Component>>,
}}

impl {} {{
    pub fn new() -> Result<Self> {{
        let root = ElementRef::new("{}")?;
"#, node.id, component_name, component_name, ui_props.html_tag.unwrap_or("div".to_string()));

        // Set attributes
        for (key, value) in &ui_props.attributes {
            code.push_str(&format!(r#"        root.set_attribute("{}", "{}")?;"#, key, value));
        }

        // Set Tailwind classes
        if !ui_props.tailwind_classes.is_empty() {
            let classes = ui_props.tailwind_classes.join(" ");
            code.push_str(&format!(r#"        root.set_attribute("class", "{}")?;"#, classes));
        }

        // Set content
        if let Some(content) = &ui_props.content {
            code.push_str(&format!(r#"        root.set_text_content("{}");"#, content));
        }

        code.push_str(&format!(r#"
        Ok({} {{
            root,
            children: Vec::new(),
        }})
    }}
}}

impl Component for {} {{
    fn render(&self) -> Result<ElementRef> {{
        Ok(self.root.clone())
    }}

    fn update(&mut self, _state: &AppState) -> Result<()> {{
        // Update logic for {}
        Ok(())
    }}
}}

"#, component_name, component_name, node.id));

        Ok(code)
    }

    fn generate_ui_component(&mut self, node: &Node) -> Result<String> {
        let component_name = format!("Component{}", self.next_id);
        self.next_id += 1;

        let ui_props = self.parse_ui_properties(node)?;

        let mut code = format!(r#"
// UI Component: {}
#[derive(Clone)]
pub struct {} {{
    element: ElementRef,
}}

impl {} {{
    pub fn new() -> Result<Self> {{
        let element = ElementRef::new("{}")?;
"#, node.id, component_name, component_name, ui_props.html_tag.unwrap_or("div".to_string()));

        // Set attributes
        for (key, value) in &ui_props.attributes {
            code.push_str(&format!(r#"        element.set_attribute("{}", "{}")?;"#, key, value));
        }

        // Set Tailwind classes
        if !ui_props.tailwind_classes.is_empty() {
            let classes = ui_props.tailwind_classes.join(" ");
            code.push_str(&format!(r#"        element.set_attribute("class", "{}")?;"#, classes));
        }

        // Set content
        if let Some(content) = &ui_props.content {
            code.push_str(&format!(r#"        element.set_text_content("{}");"#, content));
        }

        // Add HTMX attributes (converted to WASM event listeners)
        for (key, value) in &ui_props.htmx_attrs {
            if key == "hx-post" {
                code.push_str(&format!(r#"
        element.add_event_listener("click", |event: web_sys::Event| {{
            console_log!("POST request to: {}", event.type_());
            // TODO: Implement HTTP request to {}
        }})?;
"#, value, value));
            }
        }

        code.push_str(&format!(r#"
        Ok({} {{
            element,
        }})
    }}
}}

impl Component for {} {{
    fn render(&self) -> Result<ElementRef> {{
        Ok(self.element.clone())
    }}

    fn update(&mut self, _state: &AppState) -> Result<()> {{
        Ok(())
    }}
}}

"#, component_name, component_name));

        Ok(code)
    }

    fn generate_state(&mut self, node: &Node) -> Result<String> {
        let state_name = format!("State{}", self.next_id);
        self.next_id += 1;

        let code = format!(r#"
// State: {}
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct {} {{
    pub value: serde_json::Value,
}}

impl {} {{
    pub fn new(initial_value: serde_json::Value) -> Self {{
        {} {{
            value: initial_value,
        }}
    }}

    pub fn get(&self) -> &serde_json::Value {{
        &self.value
    }}

    pub fn set(&mut self, value: serde_json::Value) {{
        self.value = value;
    }}
}}

"#, node.id, state_name, state_name, state_name);

        Ok(code)
    }

    fn generate_main_app(&self, root_node_id: &str, components: &[String], states: &[String]) -> String {
        let mut code = format!(r#"
// Application State
#[derive(Clone)]
pub struct AppState {{
    states: HashMap<String, serde_json::Value>,
}}

impl AppState {{
    pub fn new() -> Self {{
        AppState {{
            states: HashMap::new(),
        }}
    }}

    pub fn set_state(&mut self, key: &str, value: serde_json::Value) {{
        self.states.insert(key.to_string(), value);
    }}

    pub fn get_state(&self, key: &str) -> Option<&serde_json::Value> {{
        self.states.get(key)
    }}
}}

// Component trait
pub trait Component {{
    fn render(&self) -> Result<ElementRef>;
    fn update(&mut self, state: &AppState) -> Result<()>;
}}

// Main Application
#[derive(Clone)]
pub struct KotobaApp {{
    root_component: Box<dyn Component>,
    state: AppState,
}}

impl KotobaApp {{
    pub fn new() -> Result<Self> {{
        // Initialize components
        let root_component = Box::new({}::new()?);

        Ok(KotobaApp {{
            root_component,
            state: AppState::new(),
        }})
    }}

    pub fn mount(&self, container_id: &str) -> Result<()> {{
        let window = web_sys::window().ok_or("No window")?;
        let document = window.document().ok_or("No document")?;
        let container = document.get_element_by_id(container_id)
            .ok_or("Container not found")?;

        let root_element = self.root_component.render()?;
        container.append_child(root_element.get_element())
            .map_err(|_| "Failed to mount app")?;

        console_log!("Kotoba WASM app mounted successfully!");
        Ok(())
    }}

    pub fn update(&mut self) -> Result<()> {{
        self.root_component.update(&self.state)?;
        Ok(())
    }}
}}

"#, root_node_id);

        code
    }

    fn generate_runtime_functions(&self) -> String {
        r#"
// WASM Entry Points
#[wasm_bindgen(start)]
pub fn main() {
    console_log!("Kotoba WASM runtime initialized");
}

#[wasm_bindgen]
pub fn create_app() -> Result<JsValue, JsValue> {
    match KotobaApp::new() {
        Ok(app) => Ok(serde_wasm_bindgen::to_value(&app)?),
        Err(e) => Err(serde_wasm_bindgen::to_value(&format!("Failed to create app: {}", e))?),
    }
}

#[wasm_bindgen]
pub fn mount_app(container_id: &str) -> Result<(), JsValue> {
    let mut app = KotobaApp::new()
        .map_err(|e| serde_wasm_bindgen::to_value(&format!("Failed to create app: {}", e))?)?;
    app.mount(container_id)
        .map_err(|e| serde_wasm_bindgen::to_value(&format!("Failed to mount app: {}", e))?)
}

"#.to_string()
    }

    fn get_ui_node_type(&self, node: &Node) -> Result<UiNodeType> {
        if let Some(node_type) = node.properties.get("node_type") {
            if let Some(type_str) = node_type.as_str() {
                return UiNodeType::from_str(type_str)
                    .ok_or_else(|| Error::Validation(format!("Unknown UI node type: {}", type_str)));
            }
        }
        Err(Error::Validation("Missing node_type property".to_string()))
    }

    fn parse_ui_properties(&self, node: &Node) -> Result<UiProperties> {
        UiProperties::deserialize(&node.properties)
            .map_err(|e| Error::Validation(format!("Failed to parse UI properties: {}", e)))
    }
}

// Import required crates for WASM
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsValue;
use wasm_bindgen::closure::Closure;
