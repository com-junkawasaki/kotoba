# Kotoba Analyzer

Semantic Analyzer for the Kotoba language, performing type checking, pure functional validation, and producing Intermediate Representation (IR).

This crate is a core part of the Kotoba language toolchain. It takes the Abstract Syntax Tree (AST) generated by `kotoba-parser` and performs deep semantic analysis to ensure code quality, correctness, and adherence to project-specific rules.

## Features

- **Symbol Table Construction**: Builds a comprehensive symbol table to track variables, functions, and scopes.
- **Type Checking**: (Future Work) A robust type inference and checking system.
- **Pure Functional Validation**: Enforces a strict, Haskell-inspired subset of the language to guarantee referential transparency and determinism.

## Pure Functional Validation

When enabled, the analyzer enforces a set of strict rules to eliminate side effects and non-deterministic behavior. This ensures that configurations are highly predictable, testable, and composable.

The following constructs are **forbidden**:

1.  **External Environment Access**:
    - `std.extVar(...)`: All external data must be passed explicitly as top-level arguments (TLA).
    - `std.native(...)`: Native functions are disallowed to prevent opaque side effects.

2.  **Side-Effect-like Operations**:
    - `std.trace(...)`: Logging from within the configuration is forbidden.
    - `error ...`: Using `error` for control flow is disallowed.

3.  **Inheritance and Late Binding**:
    - `self` and `super`: These keywords are forbidden in favor of function composition.
    - Field Visibility Modifiers (`::`, `:::`): All object fields must be regular `:`.

4.  **Entrypoint Contract**:
    - The root of a KotobaScript file must be a single function definition. Objects, arrays, or other expressions are not allowed at the top level.

This validation is enabled by default but can be configured in the `AnalyzerConfig`.
