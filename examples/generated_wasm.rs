// Generated by Kotoba WASM Transpiler
// This code is compiled to WebAssembly and runs in the browser

use wasm_bindgen::prelude::*;
use web_sys::{window, document, Element, HtmlElement, Node as DomNode};
use js_sys::{Object, Reflect};
use serde::{Deserialize, Serialize};

// WASM runtime imports
#[wasm_bindgen]
extern "C" {
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_u32(a: u32);

    #[wasm_bindgen(js_namespace = console, js_name = log)]
    fn log_many(a: &str, b: &str);
}

// Macro for console.log
macro_rules! console_log {
    ($($t:tt)*) => (log(&format_args!($($t)*).to_string()))
}

// DOM manipulation utilities
#[derive(Clone)]
pub struct ElementRef {
    element: Element,
}

impl ElementRef {
    pub fn new(tag: &str) -> Result<Self> {
        let window = web_sys::window().ok_or("No window")?;
        let document = window.document().ok_or("No document")?;
        let element = document.create_element(tag)
            .map_err(|_| "Failed to create element")?;

        Ok(ElementRef { element })
    }

    pub fn set_attribute(&self, name: &str, value: &str) -> Result<()> {
        self.element.set_attribute(name, value)
            .map_err(|_| "Failed to set attribute")?;
        Ok(())
    }

    pub fn set_text_content(&self, text: &str) {
        self.element.set_text_content(Some(text));
    }

    pub fn append_child(&self, parent: &ElementRef) -> Result<()> {
        parent.element.append_child(&self.element)
            .map_err(|_| "Failed to append child")?;
        Ok(())
    }

    pub fn add_event_listener<F>(&self, event: &str, callback: F) -> Result<()>
    where
        F: FnMut(web_sys::Event) + 'static,
    {
        let closure = Closure::wrap(Box::new(callback) as Box<dyn FnMut(_)>);
        self.element.add_event_listener_with_callback(event, closure.as_ref().unchecked_ref())
            .map_err(|_| "Failed to add event listener")?;
        closure.forget(); // Leak the closure to keep it alive
        Ok(())
    }

    pub fn get_element(&self) -> &Element {
        &self.element
    }
}

// View Component: todo_view
#[derive(Clone)]
pub struct View0 {
    root: ElementRef,
    children: Vec<Box<dyn Component>>,
}

impl View0 {
    pub fn new() -> Result<Self> {
        let root = ElementRef::new("div")?;
        root.set_attribute("class", "max-w-2xl mx-auto bg-white rounded-lg shadow-md p-6")?;
        root.set_attribute("id", "app")?;
        Ok(View0 {
            root,
            children: Vec::new(),
        })
    }
}

impl Component for View0 {
    fn render(&self) -> Result<ElementRef> {
        Ok(self.root.clone())
    }

    fn update(&mut self, _state: &AppState) -> Result<()> {
        // Update logic for todo_view
        Ok(())
    }
}

// UI Component: todo_title
#[derive(Clone)]
pub struct Component1 {
    element: ElementRef,
}

impl Component1 {
    pub fn new() -> Result<Self> {{
        let element = ElementRef::new("h1")?;
        element.set_attribute("class", "text-3xl font-bold text-gray-800 mb-6 text-center")?;
        element.set_text_content("Kotoba Todo App - WASM");
        Ok(Component1 {{
            element,
        }})
    }}
}

impl Component for Component1 {{
    fn render(&self) -> Result<ElementRef> {{
        Ok(self.element.clone())
    }}

    fn update(&mut self, _state: &AppState) -> Result<()> {{
        Ok(())
    }}
}}

// UI Component: todo_form
#[derive(Clone)]
pub struct Component2 {{
    element: ElementRef,
}}

impl Component2 {{
    pub fn new() -> Result<Self> {{
        let element = ElementRef::new("form")?;
        element.set_attribute("class", "flex gap-2 mb-6")?;
        element.set_attribute("id", "todo-form")?;
        element.add_event_listener("submit", |event: web_sys::Event| {{
            event.prevent_default();
            console_log!("Form submitted - WASM event handling!");
            // TODO: Implement form submission logic
        }})?;
        Ok(Component2 {{
            element,
        }})
    }}
}

impl Component for Component2 {{
    fn render(&self) -> Result<ElementRef> {{
        Ok(self.element.clone())
    }}

    fn update(&mut self, _state: &AppState) -> Result<()> {{
        Ok(())
    }}
}}

// UI Component: todo_input
#[derive(Clone)]
pub struct Component3 {{
    element: ElementRef,
}}

impl Component3 {{
    pub fn new() -> Result<Self> {{
        let element = ElementRef::new("input")?;
        element.set_attribute("class", "flex-1 px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500")?;
        element.set_attribute("type", "text")?;
        element.set_attribute("id", "todo-input")?;
        element.set_attribute("placeholder", "Add a new todo...")?;
        element.set_attribute("required", "true")?;
        Ok(Component3 {{
            element,
        }})
    }}
}

impl Component for Component3 {{
    fn render(&self) -> Result<ElementRef> {{
        Ok(self.element.clone())
    }}

    fn update(&mut self, _state: &AppState) -> Result<()> {{
        Ok(())
    }}
}}

// UI Component: todo_submit
#[derive(Clone)]
pub struct Component4 {{
    element: ElementRef,
}}

impl Component4 {{
    pub fn new() -> Result<Self> {{
        let element = ElementRef::new("button")?;
        element.set_attribute("class", "px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500")?;
        element.set_attribute("type", "submit")?;
        element.set_text_content("Add Todo");
        Ok(Component4 {{
            element,
        }})
    }}
}

impl Component for Component4 {{
    fn render(&self) -> Result<ElementRef> {{
        Ok(self.element.clone())
    }}

    fn update(&mut self, _state: &AppState) -> Result<()> {{
        Ok(())
    }}
}}

// UI Component: todo_list
#[derive(Clone)]
pub struct Component5 {{
    element: ElementRef,
}}

impl Component5 {{
    pub fn new() -> Result<Self> {{
        let element = ElementRef::new("div")?;
        element.set_attribute("id", "todo-list")?;
        element.set_attribute("class", "space-y-3")?;
        element.set_text_content("<div class=\"text-center text-gray-500 py-8\">No todos yet. Add one above!</div>");
        Ok(Component5 {{
            element,
        }})
    }}
}

impl Component for Component5 {{
    fn render(&self) -> Result<ElementRef> {{
        Ok(self.element.clone())
    }}

    fn update(&mut self, _state: &AppState) -> Result<()> {{
        Ok(())
    }}
}}

// Application State
#[derive(Clone)]
pub struct AppState {{
    states: std::collections::HashMap<String, serde_json::Value>,
}}

impl AppState {{
    pub fn new() -> Self {{
        AppState {{
            states: std::collections::HashMap::new(),
        }}
    }}

    pub fn set_state(&mut self, key: &str, value: serde_json::Value) {{
        self.states.insert(key.to_string(), value);
    }}

    pub fn get_state(&self, key: &str) -> Option<&serde_json::Value> {{
        self.states.get(key)
    }}
}}

// Component trait
pub trait Component {{
    fn render(&self) -> Result<ElementRef>;
    fn update(&mut self, state: &AppState) -> Result<()>;
}}

// Main Application
#[derive(Clone)]
pub struct KotobaApp {{
    root_component: Box<dyn Component>,
    state: AppState,
}}

impl KotobaApp {{
    pub fn new() -> Result<Self> {{
        // Initialize components
        let root_component = Box::new(View0::new()?);

        Ok(KotobaApp {{
            root_component,
            state: AppState::new(),
        }})
    }}

    pub fn mount(&self, container_id: &str) -> Result<()> {{
        let window = web_sys::window().ok_or("No window")?;
        let document = window.document().ok_or("No document")?;
        let container = document.get_element_by_id(container_id)
            .ok_or("Container not found")?;

        let root_element = self.root_component.render()?;
        container.append_child(root_element.get_element())
            .map_err(|_| "Failed to mount app")?;

        console_log!("Kotoba WASM app mounted successfully!");
        Ok(())
    }}

    pub fn update(&mut self) -> Result<()> {{
        self.root_component.update(&self.state)?;
        Ok(())
    }}
}}

// WASM Entry Points
#[wasm_bindgen(start)]
pub fn main() {{
    console_log!("Kotoba WASM runtime initialized");
}}

#[wasm_bindgen]
pub fn create_app() -> Result<JsValue, JsValue> {{
    match KotobaApp::new() {{
        Ok(app) => Ok(serde_wasm_bindgen::to_value(&app)?),
        Err(e) => Err(serde_wasm_bindgen::to_value(&format!("Failed to create app: {{}}", e))?),
    }}
}}

#[wasm_bindgen]
pub fn mount_app(container_id: &str) -> Result<(), JsValue> {{
    let mut app = KotobaApp::new()
        .map_err(|e| serde_wasm_bindgen::to_value(&format!("Failed to create app: {{}}", e))?)?;
    app.mount(container_id)
        .map_err(|e| serde_wasm_bindgen::to_value(&format!("Failed to mount app: {{}}", e))?)
}}

// Import required crates for WASM
use wasm_bindgen::prelude::*;
use wasm_bindgen::JsValue;
use wasm_bindgen::closure::Closure;
